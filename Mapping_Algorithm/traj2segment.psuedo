// 아직 구현 안된 부분
// - 매핑 오류 추정 부분

trajectory2segment(traj)
{
    gps_index = 0
    segment_index = 0
    mapping = {}
    segments = {}
    segments = find_segment(traj[gps_index])
    s_gps = traj[gps_index]
    

    for gps in traj[1:]
    {
        p2p_distance = min_distance(s_gps, e_gps = gps)
                
        if p2p_distance > p2p_value  // GPS들의 거리를 먼저구해 임계값의 포함되면 아래와 같은 계산을 하지 않고 매핑
        {
            segment_range = impute_segment_range(gps, segments[segment_index][geometry])
            
            if sement_range contain gps  // 범위를 먼저하는 찾는 이유는 범위를 벗어나면 다음 새그먼트를 가져와 현재 GPS랑 비교를 해야 하기 때문 
            {
                p2s_distance = min_distance(gps, segments[segment_index][geometry])
                heading = bearing(s_gps , e_gps = gps, segments[segment_index][geometry])

                if p2s_distance < p2s_value & heading
                {
                    mapping[str(gps)] = {segments[segment_index][link_id]}
                    gps_index = traj.index(gps)
                    s_gps = traj[gps_index]
                }
                else
                {
                    처리해야함 --- (링크 유실, 매핑오류) 2가지
                }
            }
            else
            {
                segments = next_segments(segments[segment_index][link_id]) // 다음 새그먼트를 현재 새그먼트로 변환
                p2s_distance = min_distance(gps, segments[segment_index][geometry])
                heading = bearing(s_gps , e_gps = gps, segments[segment_index][geometry])
                
                if p2s_distance < p2s_value & heading
                {
                    if len(segments) == 1
                    {
                        // next segment가 하나일 때
                    }
                    else if len(segments) <= 2
                    {
                        // next segment가 두개일 이상 때
                    }
                    else
                    {
                        // next segment가 없을 때 --- (링크 유실, 매핑오류) 2가지
                    }
                }
            }
        }
        else
        {
            mapping[str(gps)] = {segments[segment_index][link_id]}
        }
    }
}


find_segment(gps)
{
    // GPS에 가장 가까운 세그먼트 k 개를 찾음
    // segments = {[link_id:{F_node, T_node, Lenth, geometry:[gps1, ... gpsn]}, ... ]}
    return segments
}

impute_segment_range(gps, segment)
{
    // gps가 segment의 양 끝 점을 기준으로 포함되었는지 확인
    return True or False
}

min_distance(gps1, gps2, segment)
{
    // 2개의 GPS의 거리를 계산 or GPS와 segment의 거리를 계산
    return int
}

bearing(s_gps, e_gps, segment)
{
    // 두 GPS의 heading value와 segment heading value를 비교하여 유사하면 True, 아니면 Flase
    return True or False
}

next_segments(segment)
{
    // segment의 F_node, T_node를 통해서 연결되는 segment를 찾음
    // segments = {[link_id:{F_node, T_node, Lenth, geometry:[gps1, ... gpsn]}, ... ]}
    return segments
}